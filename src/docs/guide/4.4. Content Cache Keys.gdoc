The Springcache plugin uses an instance of the interface @grails.plugin.springcache.web.key.KeyGenerator@ to generate the cache key. If you want to use a different key generator for a particular action you just need to add the @grails.plugin.springcache.annotations.CacheKeyStrategy@ annotation alongside the @\@Cacheable@ annotation. The annotation takes a single argument which is the @KeyGenerator@ class to use. At request time a new instance will be created and used to generate keys for that action.

{code}
	@Cacheable("albumControllerCache")
	@CacheKeyStrategy(MyKeyGenerator)
	def list = {
	    // ...
	}
{code}

As with @\@Cacheable@ you can apply the @\@CacheKeyStrategy@ annotation at the class level as well as at the action level.

{note}
The @\@CacheKeyStrategy@ annotation is only for content caching and just works on controllers, it cannot be used on service methods.
{note}

h3. Key generator types

The plugin provides the following implementations of the @KeyGenerator@ interface:

h4. @grails.plugin.springcache.web.key.DefaultKeyGenerator@

The @DefaultKeyGenerator@ generates a key based on the controller name, action name and any request parameters (which can be from a query string, _POST_ body or those added by Grails URL mappings, e.g. the _id_ parameter on a standard _show_ or _edit_ action).

h4. @grails.plugin.springcache.web.key.MimeTypeAwareKeyGenerator@

The @MimeTypeAwareKeyGenerator@ extends @DefaultKeyGenerator@ and adds the request format to the key. You should use this key generator for actions that perform content negotiation, e.g. by using a @withFormat@ block.

h3. Overriding the default key generator

If you want _all_ the cached actions in your applications to use a different @KeyGenerator@ implementation instead of having to add @\@CacheKeyStrategy@ annotations everywhere you can just override the Spring bean property on the filter in @Config.groovy@ like this:

{code}
beans {
    springcacheFilter {
		defaultKeyGenerator = new MyKeyGenerator()
	}
}
{code}
