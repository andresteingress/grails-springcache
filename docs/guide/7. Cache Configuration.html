<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>7. Cache Configuration</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="7. Cache Configuration">7. Cache Configuration</a></h1>Caches referenced by the annotations can be configured, either in an <code>ehcache.xml</code> (usually kept in the <code>grails-app/conf</code> directory) file, using <code>EhCacheFactoryBean</code> definitions in <code>grails-app/conf/spring/resources.groovy</code> or via <code>Config.groovy</code>. If you do not configure caches individually they will be created on demand using defaults.<p class="paragraph"/><h3>Configuring caches with resources.groovy</h3><p class="paragraph"/>You can configure caches in <code>grails-app/conf/spring/resources.groovy</code> using instances of Spring's <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/cache/ehcache/EhCacheFactoryBean.html" target="blank">EhCacheFactoryBean</a> class. For example:<p class="paragraph"/><h4>grails-app/conf/spring/resources.groovy</h4><p class="paragraph"/><div class="code"><pre>pirateCache(EhCacheFactoryBean) &#123; bean &#45;&#62;
    cacheManager = ref(<span class="java&#45;quote">"springcacheCacheManager"</span>)
    cacheName = <span class="java&#45;quote">"pirateCache"</span>
    // these are just examples of properties you could set
    eternal = <span class="java&#45;keyword">false</span>
    diskPersistent = <span class="java&#45;keyword">false</span>
    memoryStoreEvictionPolicy = <span class="java&#45;quote">"LRU"</span>
&#125;</pre></div><p class="paragraph"/>You can inherit default cache properties from those defined in <code>Config.groovy</code> by setting the factory bean's parent to '<code>springcacheDefaultCache</code>'. For example:<p class="paragraph"/><div class="code"><pre>pirateCache(EhCacheFactoryBean) &#123; bean &#45;&#62;
    bean.parent = ref(<span class="java&#45;quote">"springcacheDefaultCache"</span>)
    cacheName = <span class="java&#45;quote">"pirateCache"</span>
    // set any properties unique to <span class="java&#45;keyword">this</span> cache
    memoryStoreEvictionPolicy = <span class="java&#45;quote">"LRU"</span>
&#125;</pre></div><p class="paragraph"/><h3>Configuring caches with Config.groovy</h3><p class="paragraph"/>The Springcache plugin enables you to define caches in <code>Config.groovy</code> for convenience. For example:<p class="paragraph"/><h4>grails-app/conf/Config.groovy</h4><p class="paragraph"/><div class="code"><pre>springcache &#123;
    defaults &#123;
        // set <span class="java&#45;keyword">default</span> cache properties that will apply to all caches that <span class="java&#45;keyword">do</span> not override them
        eternal = <span class="java&#45;keyword">false</span>
        diskPersistent = <span class="java&#45;keyword">false</span>
    &#125;
    caches &#123;
        pirateCache &#123;
            // set any properties unique to <span class="java&#45;keyword">this</span> cache
            memoryStoreEvictionPolicy = <span class="java&#45;quote">"LRU"</span>
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>Under the hood this is simply setting up <code>EhCacheFactoryBean</code> instances in the Spring context, so it is up to you whether you prefer to use <code>resources.groovy</code> or <code>Config.groovy</code> there is not much difference.<p class="paragraph"/>The properties shown are just examples, see the <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/cache/ehcache/EhCacheFactoryBean.html" target="blank">EhCacheFactoryBean</a> documentation for full details of all the properties you can set.
<h2><a name="8.1. Tips">8.1. Tips</a></h2><h3>Flushing content caches with service methods and vice-versa</h3><p class="paragraph"/>There is nothing special about the different types of cache so it's perfectly fine to flush a content cache with a <code>&#64;CacheFlush</code> annotation on a service method or a service method cache with a <code>&#64;CacheFlush</code> annotation on a controller action. There's also no reason that you shouldn't use the same cache for both service method and content caching the keys will be quite distinct so this will not be a problem.<p class="paragraph"/><h3>Tearing down caches in tests</h3><p class="paragraph"/>In integration test and some types of functional test (e.g. <a href="http://grails.org/plugin/selenium-rc" target="blank">Selenium RC</a> tests when not running in remote mode) your tests can have Spring beans automatically injected. You can use this facility to tear down caches between tests. For example:<p class="paragraph"/><div class="code"><pre>def springcacheService // auto&#45;injected service bean from plugin<p class="paragraph"/>void tearDown() &#123;
    <span class="java&#45;keyword">super</span>.tearDown()
    springcacheService.flushAll()
    // only need to <span class="java&#45;keyword">do</span> <span class="java&#45;keyword">this</span> <span class="java&#45;keyword">if</span> your tests are making assertions about hit/miss counts, etc.
    springcacheService.clearStatistics()
&#125;</pre></div><p class="paragraph"/><h3>Disabling</h3><p class="paragraph"/>Rather than tearing down caches between tests you may prefer to disable the plugin altogether. This is done by setting the config key <code>springcache.enabled = false</code> which can be done on a per-environment basis. For example:<p class="paragraph"/><div class="code"><pre>springcache &#123;
    // cache definitions, etc
&#125;<p class="paragraph"/>environments &#123;
    development &#123;
        springcache.enabled = <span class="java&#45;keyword">false</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>Whilst this makes things simpler I would encourage you to run end-to-end tests and continuous integration in as 'production-like' an environment as possible. If your continuous integration build is running with the plugin enabled you are much less likely to get any surprising behaviour when you release your app to a production environment.<p class="paragraph"/><h3>Logging</h3><p class="paragraph"/>To see logging from the plugin set the logging level on <code>grails.plugin.springcache</code> in your <code>Config.groovy</code> file.<p class="paragraph"/><h3>Response headers</h3><p class="paragraph"/>The plugin sets a header  <em class="italic">X-Springcache-Cached</em>  with a value of  <em class="italic">true</em>  or  <em class="italic">false</em>  to indicate whether or not a controller response was served from the cache. This only applies to the "main" request and not to any content included using the <code>g:include</code> tag.
<h2><a name="8.2. FAQ">8.2. FAQ</a></h2><h3>Can I evict only some of the contents of a cache instead of flushing the whole thing?</h3><p class="paragraph"/>No. It's not possible to 'reverse engineer' cache keys into the values that were used to generate them so how would you know which keys to evict? If you find yourself asking this question you should consider using more focused caches rather than putting everything into the same bucket. The pursuit of 100% efficiency where no service method or controller action is  <em class="italic">ever</em>  invoked when its contents could conceivably have been served from a cache is subject to the law of diminishing returns. Any time you flush a cache you may well discard  <em class="italic">some</em>  entries that  <em class="italic">could</em>  potentially still have been used but so long as your caches are set up sensibly that's really not something that you should worry about.<p class="paragraph"/><h3>My cache config doesn't seem to be working.</h3><p class="paragraph"/>Ensure all your config for the  <em class="italic">Springcache</em>  plugin is nested inside a single <code>springcache</code> block in <code>Config.groovy</code> otherwise only the last block will take effect.<p class="paragraph"/><h3>Can I programatically disable caching in specific circumstances such as when a user is logged in?</h3><p class="paragraph"/>In the case of controller caching you can do so by setting a  <em class="italic">Cache-Control</em>  response header with a value of  <em class="italic">"no-cache"</em>  which can be done manually, or by using the command <code>cache false</code> provided by the <a href="http://grails.org/plugin/cache-headers" target="blank">Cache Headers</a> plugin. See <a href="../guide/single.html#4.4. Cache Headers" class="guide">Cache Headers</a><p class="paragraph"/><h3>Why isn't there a taglib so I can just wrap parts of my page that need caching?</h3><p class="paragraph"/>It's something I may add but from a purist point of view I'm not very keen on the idea. Caching is a separate concern from view rendering and the two really shouldn't be mixed up. So far the plugin has deliberately taken a declarative approach to caching which encourages you to maintain a good separation of concerns.<p class="paragraph"/>If this is something you really want to see, vote for the issue on JIRA here: "GRAILSPLUGINS-2564":http://jira.codehaus.org/browse/GRAILSPLUGINS-2564<h2><a name="8.3. Upgrading From Earlier Versions">8.3. Upgrading From Earlier Versions</a></h2>Successive versions of the plugin have introduced some non-backwards compatible changes. If you are upgrading from an earlier version you will need to consider the following:<p class="paragraph"/><h4>Upgrading from 1.2.* to 1.3:</h4>
<ul class="star">
<li>You can no longer inject  <em class="italic">keyGenerator</em>  into the  <em class="italic">springcacheFilter</em>  bean. Instead you can override the  <em class="italic">springcacheDefaultKeyGenerator</em>  bean or specify the  <em class="italic">keyGenerator</em>  element on individual <code>&#64;Cacheable</code> annotations. See <a href="../guide/single.html#4.5. Content Cache Keys" class="guide">Content Cache Keys</a></li>
</ul><p class="paragraph"/><h4>Upgrading from 1.1.* to 1.2:</h4>
<ul class="star">
<li>The plugin no longer uses caching and flushing models. Instead cache names are referenced directly by the annotations. This means you will need to 'inline' your model definitions from <code>Config.groovy</code> to your annotations.</li>
<li>The plugin no longer supports alternate cache libraries, it's  <em class="italic">EhCache</em>  or nothing.</li>
</ul><p class="paragraph"/><h4>From pre 1.1:</h4>
<ul class="star">
<li>You will need to change the import statements for your <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations to point to the <code>grails.plugin.springcache.annotations</code> package.</li>
</ul><p class="paragraph"/>
    </body>
</html>
