<html>
    <head>
        <title>Spring Cache Plugin 1.3 - Reference Documentation</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Style" charset="utf-8"/>
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    </head>
    <body class="body">
        <div id="header">
            <div class="images"><br/><br/>
                <a href="http://grails.org" target="_blank"><img alt="The Grails Framework" src="../img/grails.png" border="0"/></a>
                <span style="right:30px; top:20px; position:absolute;">
                    <a href="../index.html" target="_top">Frames</a> | <a href="index.html" target="_top">No Frames</a><br/><br/>
                    <a href="http://springsource.com" target="_blank"><img alt="SpringSource - A Division of VMware" src="../img/springsource-logo.png" border="0"/></a>
                </span>
            </div>
            <div class="message">Provides annotation-driven caching of service methods and page fragments</div>
            <h1>Spring Cache Plugin - Reference Documentation</h1>
            <p><strong>Authors:</strong> Grails Plugin Collective</p>
            <p><strong>Version:</strong> 1.3</p>
            <em>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</em>
        </div>

        <div id="toc">
            <h2>Table of Contents</h2>
            <div class="tocItem" style="margin-left:0px"><a href="#1. Introduction">1. Introduction</a></div><div class="tocItem" style="margin-left:10px"><a href="#1.1. Known Issues">1.1. Known Issues</a></div><div class="tocItem" style="margin-left:10px"><a href="#1.2. Release Notes">1.2. Release Notes</a></div><div class="tocItem" style="margin-left:0px"><a href="#2. The Cacheable and CacheFlush Annotations">2. The Cacheable and CacheFlush Annotations</a></div><div class="tocItem" style="margin-left:0px"><a href="#3. Caching Service Methods">3. Caching Service Methods</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.1. Service Method Cache Keys">3.1. Service Method Cache Keys</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.2 Calling Cached Methods Internally">3.2 Calling Cached Methods Internally</a></div><div class="tocItem" style="margin-left:0px"><a href="#4. Content Caching">4. Content Caching</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.1. Caching and Flushing with Controller Actions">4.1. Caching and Flushing with Controller Actions</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.2. Content Caching and SiteMesh">4.2. Content Caching and SiteMesh</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.3. Using Annotations at Class Level">4.3. Using Annotations at Class Level</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.4. Cache Headers">4.4. Cache Headers</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.5. Content Cache Keys">4.5. Content Cache Keys</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.6. Content Negotiation">4.6. Content Negotiation</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.7. Full Page Caching">4.7. Full Page Caching</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.8. TagLib Caching">4.8. TagLib Caching</a></div><div class="tocItem" style="margin-left:0px"><a href="#5. Cache Selection">5. Cache Selection</a></div><div class="tocItem" style="margin-left:0px"><a href="#6. Programmatic Caching and Flushing">6. Programmatic Caching and Flushing</a></div><div class="tocItem" style="margin-left:0px"><a href="#7. Cache Configuration">7. Cache Configuration</a></div><div class="tocItem" style="margin-left:10px"><a href="#8.1. Tips">8.1. Tips</a></div><div class="tocItem" style="margin-left:10px"><a href="#8.2. FAQ">8.2. FAQ</a></div><div class="tocItem" style="margin-left:10px"><a href="#8.3. Upgrading From Earlier Versions">8.3. Upgrading From Earlier Versions</a></div>
        </div>
        <div id="content">
            <h1><a name="1. Introduction">1. Introduction</a></h1>The <em class="italic">Springcache</em> plugin allows you to easily add the following functionality to your Grails project:
<ul class="star">
<li>Caching of Spring bean methods (typically Grails service methods).</li>
<li>Caching of page fragments generated by Grails controllers.</li>
<li>Cache flushing when Spring bean methods or controller actions are invoked.</li>
</ul><p class="paragraph"/>The plugin depends on the <a href="http://ehcache.org/" target="blank">EhCache</a> and <a href="http://ehcache.org/documentation/web_caching.html" target="blank">EhCache-Web</a> libraries.<p class="paragraph"/><h3>Contact</h3><p class="paragraph"/>The plugin code is hosted on <a href="http://github.com/robfletcher/grails-springcache" target="blank">GitHub</a>. Please feel free to fork the plugin and contribute patches.<p class="paragraph"/>Please raise defects or enhancements against the Grails Springcache plugin component on the <a href="http://jira.codehaus.org/browse/GRAILSPLUGINS/component/14010" target="blank">Codehaus JIRA</a>.<p class="paragraph"/>Questions, comments? mailto:rob</code>energizedwork.com or better still contact me via the <a href="http://grails.org/Mailing+lists" target="blank">Grails User mailing list</a>.
<h2><a name="1.1. Known Issues">1.1. Known Issues</a></h2><ul class="star">
<li><a href="http://jira.codehaus.org/browse/GRAILSPLUGINS-2553" target="blank">GRAILSPLUGINS-2553</a> Cached methods with default arguments are not intercepted unless all the arguments are specified. Therefore the cache is completely bypassed (neither hit or missed).</li>
<li><a href="http://jira.codehaus.org/browse/GRAILSPLUGINS-2544" target="blank">GRAILSPLUGINS-2544</a> Due to a bug with Grails itself query string parameters are not included in the generated cache key. This can be a serious issue if you are using pagination for example as query string parameters such as <code>offset</code> will be ignored resulting in the same cached content being served for every page. This <strong class="bold">only</strong> affects Grails version 1.3.4.</li>
</ul><p class="paragraph"/><h2><a name="1.2. Release Notes">1.2. Release Notes</a></h2><h4>1.3</h4>
<ul class="star">
<li>Fixes bug where layout is not applied to cached content when applied by convention rather than explicitly declared in meta tag <a href="http://jira.codehaus.org/browse/GRAILSPLUGINS-2541" target="blank">GRAILSPLUGINS-2541</a></li>
<li>Adds <code>keyGenerator</code> element to <code>&#64;Cacheable</code> annotation <a href="http://jira.codehaus.org/browse/GRAILSPLUGINS-2548" target="blank">GRAILSPLUGINS-2548</a></li>
<li>Adds <code>cacheResolver</code> element to <code>&#64;Cacheable</code> annotation <a href="http://jira.codehaus.org/browse/GRAILSPLUGINS-2167" target="blank">GRAILSPLUGINS-2167</a></li>
<li>Content caching now respects cache control headers <a href="http://jira.codehaus.org/browse/GRAILSPLUGINS-2616" target="blank">GRAILSPLUGINS-2616</a></li>
<li>Adds ability to cache taglib output <a href="http://jira.codehaus.org/browse/GRAILSPLUGINS-2569" target="blank">GRAILSPLUGINS-2569</a></li>
<li>Deprecates <code>springcache.disabled = true</code> in favour of <code>springcache.enabled = false</code></li>
<li>Fixes bug with key generation from String parameters</li>
<li>Updates <em class="italic">ehcache-web</em> to version 2.0.2</li>
<li>Makes <code>SpringcacheService</code> methods safe no-ops when plugin is disabled <a href="http://jira.codehaus.org/browse/GRAILSPLUGINS-2497" target="blank">GRAILSPLUGINS-2497</a></li>
</ul><p class="paragraph"/><h4>1.2.1</h4>
<ul class="star">
<li>Support primitive, array and <code>null</code> service method arguments in cache keys (thanks Luke Daley)</li>
</ul><p class="paragraph"/><h4>1.2</h4>
<ul class="star">
<li>Adds page fragment caching via annotations on controllers.</li>
<li>Simplifies config by getting rid of caching and flushing models and having annotations refer to cache names directly.</li>
<li>Adds configurable cache defaults that apply to configured caches and auto-created caches</li>
<li>Removes pluggable cache implementation in favour of using EhCache.</li>
</ul><p class="paragraph"/><h4>1.1.3</h4>
<ul class="star">
<li>Fixes bug where an expired ehcache element whose key is still in the cache can cause the plugin to think the key still maps to a valid value.</li>
<li>Allows configuration of ehcache caches directly in <code>Config.groovy</code></li>
</ul><p class="paragraph"/><h4>1.1.2</h4>
<ul class="star">
<li>Automatically create ehcache caches if they are not explicitly configured in <code>ehcache.xml</code></li>
</ul><p class="paragraph"/><h4>1.1.1</h4>
<ul class="star">
<li>Fixes bug where plugin crashes if disabled</li>
</ul><p class="paragraph"/><h4>1.1</h4>
<ul class="star">
<li>Complete rewrite to support Grails 1.2 and Spring 3.0.</li>
<li>Requires Grails 1.2+</li>
</ul><p class="paragraph"/><h4>1.0.1</h4>
<ul class="star">
<li>Fixes bug where plugin causes crash if disabled when debug logging is switched on.</li>
<li>Fixes compatibility with Java 1.5.</li>
</ul><p class="paragraph"/><h4>1.0</h4>
<ul class="star">
<li>Configure alternate caching providers via <code>Config.groovy</code> rather than having to override bean definitions in <code>resources.groovy</code></li>
<li>Removed dependency on joda-time which was only there for testing</li>
<li>Better synchronization for getting caches from the mapcache CacheManager</li>
</ul><p class="paragraph"/><h4>0.2</h4>
<ul class="star">
<li>Configure caching and flushing models via <code>Config.groovy</code></li>
<li>Flag to disable plugin entirely for testing environments</li>
</ul><p class="paragraph"/><h4>0.1</h4>
<ul class="star">
<li>Initial release</li>
</ul><p class="paragraph"/><h1><a name="2. The Cacheable and CacheFlush Annotations">2. The Cacheable and CacheFlush Annotations</a></h1>The <em class="italic">Springcache</em> plugin provides two annotations that are the basis of how you can apply caching and flushing behaviour to both Spring bean methods and page fragments. Both annotations are in the <code>grails.plugin.springcache.annotations</code> package.<p class="paragraph"/><h3>The <code>&#64;Cachable</code> annotation</h3><p class="paragraph"/>The <code>Cacheable</code> annotation is applied to methods on Spring managed beans such as Grails services to cache method results or to controller actions to cache page fragments. The annotation requires a cache name specified either as a standalone value or with the <code>cache</code> element. The following declarations are equivalent:<p class="paragraph"/><div class="code"><pre>&#64;Cacheable(<span class="java&#45;quote">"myCache"</span>)
&#64;Cacheable(cache = <span class="java&#45;quote">"myCache"</span>)</pre></div><p class="paragraph"/>To resolve the cache name in a non-standard way you can supply a <code>cacheResolver</code> element, see <a href="../guide/single.html#5. Cache Selection" class="guide">Cache Selection</a>. For content caching only you can also supply a <code>keyGenerator</code> element, see <a href="../guide/single.html#4.5. Content Cache Keys" class="guide">Content Cache Keys</a><p class="paragraph"/><h3>The <code>&#64;CacheFlush</code> annotation</h3><p class="paragraph"/>The <code>CacheFlush</code> annotation can be applied in the same places as the <code>Cacheable</code> annotation but instead of caching results it will cause a cache or set of caches to be flushed. The <code>CacheFlush</code> annotation requires a single element or a String array either as a standalone value or with the <code>caches</code> element. Either way the elements can simply be literal cache names or regular expression patterns that may match multiple cache names. For example:<p class="paragraph"/><div class="code"><pre>&#64;CacheFlush(<span class="java&#45;quote">"myCache"</span>)
&#64;CacheFlush(/&#119;+ControllerCache/)
&#64;CacheFlush(&#91;<span class="java&#45;quote">"cacheA"</span>, <span class="java&#45;quote">"cacheB"</span>, <span class="java&#45;quote">"cacheC"</span>&#93;)
&#64;CacheFlush(caches = &#91;<span class="java&#45;quote">"cacheA"</span>, <span class="java&#45;quote">"cacheB"</span>, <span class="java&#45;quote">"cacheC"</span>&#93;)
&#64;CacheFlush(&#91;/cache&#91;A&#45;Z&#93;/, <span class="java&#45;quote">"myCache"</span>&#93;)</pre></div><p class="paragraph"/>To resolve the cache names in a non-standard way you can supply a <code>cacheResolver</code> element, see <a href="../guide/single.html#5. Cache Selection" class="guide">Cache Selection</a>.
<h1><a name="3. Caching Service Methods">3. Caching Service Methods</a></h1>The typical use case for method caching is when you have Grails service methods that invoke expensive operations such as HTTP gets, web service calls, filesystem IO, etc.<p class="paragraph"/><blockquote class="note">
Although you <em class="italic">can</em> use the <em class="italic">Springcache</em> plugin to cache service methods that query or update <em class="italic">GORM</em> domain objects you should consider whether it's more appropriate to use the Hibernate 2nd level cache (see the relevant sections in the Grails documentation). In some cases using <em class="italic">Springcache</em> does make sense, e.g. a service that aggregates the results of multiple queries.
</blockquote><p class="paragraph"/>Simply add an <code>&#64;Cacheable</code> annotation to methods that should cache their results and a <code>&#64;CacheFlush</code> annotation to methods that should flush caches.<p class="paragraph"/><blockquote class="note">
Be aware that the annotations will only have any effect on Spring-managed beans. If you create instances of your class directly rather than getting them from the application context they will not be decorated with caching/flushing behaviour.
</blockquote><p class="paragraph"/><blockquote class="note">
Method caching requires AspectJ auto-weaving to be enabled. If you have <code>grails.spring.disable.aspectj.autoweaving = false</code> set in config then method caching will not work. Content caching is unaffected as it uses a different mechanism.
</blockquote><p class="paragraph"/>A simple example might be:<p class="paragraph"/><h4>PiracyService.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"pirateCache"</span>)
def getPirates() &#123;
    // <span class="java&#45;keyword">return</span> a list of pirates
&#125;<p class="paragraph"/>@Cacheable(<span class="java&#45;quote">"pirateCache"</span>)
def findPirates(name) &#123;
    // <span class="java&#45;keyword">return</span> a particular pirate
&#125;<p class="paragraph"/>@Cacheable(<span class="java&#45;quote">"shipCache"</span>)
def getShips() &#123;
    // <span class="java&#45;keyword">return</span> a list of ships
&#125;<p class="paragraph"/>@CacheFlush(<span class="java&#45;quote">"pirateCache"</span>)
void registerNewPirate(Pirate sailor) &#123;
    // store a <span class="java&#45;keyword">new</span> pirate
&#125;<p class="paragraph"/>@CacheFlush(<span class="java&#45;quote">"shipCache"</span>)
void registerNewShip(Ship ship) &#123;
    // store a <span class="java&#45;keyword">new</span> ship
&#125;<p class="paragraph"/>@CacheFlush(&#91;<span class="java&#45;quote">"pirateCache"</span>, <span class="java&#45;quote">"shipCache"</span>&#93;)
void registerNewShipWithCrew(Ship ship, Collection&#60;Sailor&#62; crew) &#123;
    // store a <span class="java&#45;keyword">new</span> ship and associated pirates
&#125;</pre></div><p class="paragraph"/>This ties the flushes on the <em class="italic">register</em> methods to the particular caches they affect, so after calling <code>registerNewPirate</code> the methods <code>getPirates</code> and <code>findPirates</code> will re-populate their cached results but <code>getShips</code> would still use any cached results from previous calls. Calling <code>registerNewShipWithCrew</code> will flush both caches.<p class="paragraph"/>It is fine for multiple methods to share the same caches. Both <code>getPirates</code> and <code>findPirates</code> in the example above share the same cache. Cache entries are keyed on target object (the service instance in this case), method name and call parameters so there should be no confusion when using the same caches on multiple methods.<p class="paragraph"/>There are various strategies you can adopt in naming and grouping caches, this example shouldn't be seen as definitive.
<h2><a name="3.1. Service Method Cache Keys">3.1. Service Method Cache Keys</a></h2>When a <code>&#64;Cacheable</code> annotation is found on a service method the plugin generates a key using:
<ul class="star">
<li>The <em class="italic">target</em> object, i.e. the service being called.</li>
<li>The service method name.</li>
<li>All method parameters.</li>
</ul><p class="paragraph"/>Since Grails services are typically Spring singletons the target object is not usually an issue. There's no need to implements <em class="italic">equals</em> or <em class="italic">hashCode</em> on your service classes unless you are using a different Spring bean scope and need to differentiate between calls made to different instances of the service.<p class="paragraph"/>It is, however, <strong class="bold">vital</strong> to ensure that <em class="italic">equals</em> and <em class="italic">hashCode</em> is properly implemented on all the types used as parameters to cached methods. If this is not done it is very unlikely that the cache will ever be hit.<h2><a name="3.2 Calling Cached Methods Internally">3.2 Calling Cached Methods Internally</a></h2>Service method caching is implemented via Spring AOP, which utilises proxies. In practical terms, this means that when depending on a service with a cached method in another service or controller (or anything else for that matter), you actual receive a <em class="italic">proxy</em> for the real service. This allows method calls to be intercepted and for caches to be checked or populated.<p class="paragraph"/>The implication of this however is that calls to <code>this</code> (implicit or explicit) do <strong class="bold">NOT</strong> go via the proxy.<p class="paragraph"/>Consider the following…<p class="paragraph"/><div class="code"><pre>class ExampleService &#123;<p class="paragraph"/>    def nonCachedMethod() &#123;
        cachedMethod()
    &#125;<p class="paragraph"/>    @Cacheable('cachedMethodCache')
    def cachedMethod() &#123;
        // <span class="java&#45;keyword">do</span> some expensive stuff
    &#125;
&#125;</pre></div><p class="paragraph"/>You may expect that the <code>nonCachedMethod()</code> will use the cache for <code>cachedMethod()</code>, but it won't. The call is made on <code>this</code> which is the actual instance and not the proxy.<p class="paragraph"/>Fortunately, there is an easy workaround…<p class="paragraph"/><div class="code"><pre>class ExampleService &#123;<p class="paragraph"/>    def grailsApplication<p class="paragraph"/>    def nonCachedMethod() &#123;
        grailsApplication.mainContext.exampleService.cachedMethod()
    &#125;<p class="paragraph"/>    @Cacheable('cachedMethodCache')
    def cachedMethod() &#123;
        // <span class="java&#45;keyword">do</span> some expensive stuff
    &#125;
&#125;</pre></div><p class="paragraph"/>Instead of calling the method on <code>this</code>, we obtain the proxy via the application context (i.e. <code>grailsApplication.mainContext.exampleService</code>) and call the method on that. This way we go through the caching mechanism.<h1><a name="4. Content Caching">4. Content Caching</a></h1>The <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations can be applied to controller actions and the plugin will then cache the page fragment generated by the controller whether this is done by rendering a GSP, using a <em class="italic">MarkupBuilder</em> closure, rendering text directly or whatever. Only successful page renders are cached, so redirects, 404s, errors and so on will not be.<p class="paragraph"/>Composing pages so that they can be optimally cached requires some thought. The plugin uses a servlet filter that runs 'inside' the SiteMesh filter provided by Grails. This means that cached output is decorated by SiteMesh and the resulting page can therefore contain uncached content from the SiteMesh template. In addition you can use caching at a modular level to cache the output of controller actions invoked using the <code>g:include</code> tag, or by caching taglib tags. Combining these techniques leads to powerful modular page caching. For example, you can cache the output of the 'main' controller then use <code>g:include</code> tags, or taglib tags, in the SiteMesh layout to include content on the page that is cached separately - and can be flushed separately - from the main body of the page.
<h2><a name="4.1. Caching and Flushing with Controller Actions">4.1. Caching and Flushing with Controller Actions</a></h2><h3>Example: caching Grails CRUD pages</h3><p class="paragraph"/>Grails' standard scaffolded <em class="italic">CRUD</em> pages provide a good example of how caching and flushing can be applied. For example, let's take an <em class="italic">Album</em> domain class. The scaffolded controller could be annotated like this:<p class="paragraph"/><h4>AlbumController.groovy</h4><p class="paragraph"/><div class="code"><pre>class AlbumController &#123;
    // the index action is uncached as it just performs a redirect to list
    def index = &#123;
        redirect(action: <span class="java&#45;quote">"list"</span>, params: params)
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def list = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def create = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @CacheFlush(&#91;<span class="java&#45;quote">"albumControllerCache"</span>, <span class="java&#45;quote">"artistControllerCache"</span>, <span class="java&#45;quote">"latestControllerCache"</span>, <span class="java&#45;quote">"popularControllerCache"</span>&#93;)
    def save = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def show = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def edit = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @CacheFlush(&#91;<span class="java&#45;quote">"albumControllerCache"</span>, <span class="java&#45;quote">"latestControllerCache"</span>, <span class="java&#45;quote">"popularControllerCache"</span>&#93;)
    def update = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @CacheFlush(&#91;<span class="java&#45;quote">"albumControllerCache"</span>, <span class="java&#45;quote">"artistControllerCache"</span>, <span class="java&#45;quote">"latestControllerCache"</span>, <span class="java&#45;quote">"popularControllerCache"</span>&#93;)
    def delete = &#123;
        // standard Grails scaffolding code omitted
    &#125;
&#125;</pre></div><p class="paragraph"/>The <em class="italic">list, show, create</em> and <em class="italic">edit</em> pages are all cached. The <em class="italic">show</em> and <em class="italic">edit</em> rely on an domain object id parameter and this will be included in the cache key so that <code>/album/show/1</code> and <code>/album/show/2</code> are cached separately. The <em class="italic">save, update</em> and <em class="italic">delete</em> actions will flush caches. Note that in addition to flushing the cache used by the <em class="italic">list, show, create</em> and <em class="italic">edit</em> actions they are flushing other caches which are content caches for controllers whose output should be refreshed if <code>Album</code> data changes.
<h2><a name="4.2. Content Caching and SiteMesh">4.2. Content Caching and SiteMesh</a></h2><h3>Example: decorating a cached page with dynamic content using SiteMesh</h3><p class="paragraph"/>It is often necessary to have portions of a page be dynamic. A typical example is when something is displayed to logged in users that will be different for each user. Those sorts of page sections are not really candidates for caching. At the same time other parts of the page may well be able to take advantage of caching. For example, if you want to display a <em class="italic">"Welcome back $username"</em> type message in page headers while caching the main body of the page you can use SiteMesh templates like this:<p class="paragraph"/><h4>grails-app/views/layouts/main.gsp</h4><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
    &#60;head&#62;
        &#60;title&#62;&#60;g:layoutTitle <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Welcome to My Grails Application"</span>/&#62;&#60;/title&#62;
        &#60;%&#45;&#45; render the page head from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutHead/&#62;
    &#60;/head&#62;
    &#60;body&#62;
        &#60;%&#45;&#45; render a <span class="java&#45;quote">"welcome back"</span> header (tags used here are from the Spring Security plugin) &#45;&#45;%&#62;
        &#60;g:isLoggedIn&#62;
            &#60;div id=<span class="java&#45;quote">"loggedInUser"</span>&#62;&#60;g:message code=<span class="java&#45;quote">"auth.loggedInAs"</span> args=<span class="java&#45;quote">"&#91;loggedInUsername()&#93;"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Logged in as &#123;0&#125;"</span>/&#62;&#60;/div&#62;
        &#60;/g:isLoggedIn&#62;
        &#60;g:isNotLoggedIn&#62;
            &#60;div id=<span class="java&#45;quote">"loginLink"</span>&#62;&#60;g:link controller=<span class="java&#45;quote">"login"</span>&#62;&#60;g:message code=<span class="java&#45;quote">"<span class="java&#45;keyword">default</span>.login.label"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Login here"</span>/&#62;&#60;/g:link&#62;&#60;/div&#62;
        &#60;/g:isNotLoggedIn&#62;<p class="paragraph"/>        &#60;%&#45;&#45; render the page body from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutBody/&#62;
    &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>If the controller action invoked uses <code>&#64;Cacheable</code> everything will work fine because the content of the SiteMesh layout is <em class="italic">not</em> cached - only the content generated by the cached action. The SiteMesh template is applied to cached and uncached content alike so the correct username will be displayed to your users even though the main body of the page may have been loaded from a cache.<p class="paragraph"/><h3>Example: a modular page using multiple cached sections</h3><p class="paragraph"/>One of the most powerful features of page fragment caching is that the generated page can be composed from multiple cached sections. This is accomplished using Grails' <code>g:include</code> tag. For example, in this page the main body of the page is rendered by some controller action and the output of other controllers are included in the SiteMesh layout using the <code>g:include</code> tag:<p class="paragraph"/><h4>grails-app/views/layouts/main.gsp</h4><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
    &#60;head&#62;
        &#60;title&#62;&#60;g:layoutTitle <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Welcome to My Grails Application"</span>/&#62;&#60;/title&#62;
        &#60;%&#45;&#45; render the page head from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutHead/&#62;
    &#60;/head&#62;
    &#60;body&#62;
        &#60;%&#45;&#45; render the page body from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutBody/&#62;<p class="paragraph"/>        &#60;div class=<span class="java&#45;quote">"sidebar"</span>&#62;
            &#60;%&#45;&#45; each of these controller actions can be cached separately as well &#45;&#45;%&#62;
            &#60;g:include controller=<span class="java&#45;quote">"latest"</span> action=<span class="java&#45;quote">"albums"</span>/&#62;
            &#60;g:include controller=<span class="java&#45;quote">"popular"</span> action=<span class="java&#45;quote">"albums"</span>/&#62;
        &#60;/div&#62;
    &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><h4>LatestController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"latestAlbums"</span>)
def albums = &#123;
    def albums = Album.list(sort: <span class="java&#45;quote">"dateCreated"</span>, order: <span class="java&#45;quote">"desc"</span>, max: 10)
    &#91;albumInstanceList: albums&#93;
&#125;</pre></div><p class="paragraph"/><h4>LatestController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"popularAlbums"</span>)
def albums = &#123;
    def albums = Album.listOrderByAverageRating(max: 10)
    <span class="java&#45;keyword">return</span> &#91;albumInstanceList: albums&#93;
&#125;</pre></div><p class="paragraph"/>If all the caches are hit the final rendered page will be composed of 3 separate cached sections. What is more, each individual section can be flushed without affecting the others so with some thought about how to compose your page and apply your caches you can optimise cache usage without delivering stale data to the user.
<h2><a name="4.3. Using Annotations at Class Level">4.3. Using Annotations at Class Level</a></h2>The <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations can be applied to controllers at class level. This is more likely useful with <code>&#64;Cacheable</code> but it is certainly possible to apply <code>&#64;CacheFlush</code> at class level so that any action on that controller will flush a set of caches. Any annotation on an individual action will be applied in preference to an annotation at class level, so a class level annotation behaves like a default. An annotation at class level will work with dynamic scaffolded actions so you don't have to generate a concrete action in order to benefit from caching behaviour.<p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
class AlbumController &#123;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> scaffold = <span class="java&#45;keyword">true</span> // all dynamically scaffolded actions will be cached<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumListCache"</span>)
    def list = &#123;
        // &#8230;
    &#125;<p class="paragraph"/>    @CacheFlush(/album&#119;+Cache/)
    def save = &#123;
        // &#8230;
    &#125;<p class="paragraph"/>    def show = &#123;
        // &#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>In this example:
<ul class="star">
<li>The <em class="italic">show</em> action will use the default class level <code>&#64;Cacheable</code> annotation and its page fragment will be cached in the <em class="italic">albumControllerCache</em> cache.</li>
<li>The <em class="italic">list</em> action will not use the default as it specifies its own <code>&#64;Cacheable</code> annotation and its content will be cached separately.</li>
<li>The <em class="italic">save</em> action uses a <code>&#64;CacheFlush</code> and will therefore not be cached at all.</li>
<li>Dynamically scaffolded actions (e.g. <em class="italic">edit_, _update_, etc.) will use the class level annotation and their results will be cached in the _albumControllerCache</em> cache.</li>
</ul><p class="paragraph"/><h2><a name="4.4. Cache Headers">4.4. Cache Headers</a></h2>Content caching in the Springcache plugin attempts to respect any cache-control headers present in the original response.
Specifically the plugin will handle certain response headers as follows:<p class="paragraph"/><h4>Cache-Control: no-cache</h4><p class="paragraph"/>If this header is present in the response the content will <em class="italic">not</em> be cached even if there is a <code>&#64;Cacheable</code> annotation
present on the controller or action. This allows you to prevent caching in certain circumstances or override the
controller-wide caching policy in a particular action.<p class="paragraph"/><h4>Cache-Control: max-age=x</h4><p class="paragraph"/>If the response is cached the time-to-live of the cache entry is set so that it corresponds to the max-age value in
the <code>Cache-Control</code> header. If no such header is present the cache's configured time-to-live is used (see <a href="../guide/single.html#7. Cache Configuration" class="guide">Cache Configuration</a>).<p class="paragraph"/><h4>ETag</h4><p class="paragraph"/>If the original response set an <code>ETag</code> header <em class="italic">Springcache</em> will set the same header if it serves the response from the
cache.
Additionally, if an incoming request has an <code>If-None-Match</code> header that matches the <code>ETag</code> of the cached response <em class="italic">Springcache</em> will send a <code>304 Not Modified</code> status code and an empty response body instead of the cached response.<p class="paragraph"/><h4>Last-Modified</h4><p class="paragraph"/>If the original response set a <code>Last-Modified</code> header <em class="italic">Springcache</em> will set the same header if it serves the response
from the cache.
Additionally, if an incoming request has an <code>If-Modified-Since</code> header with a timestamp later than the
<code>Last-Modified</code> header of the cached response <em class="italic">Springcache</em> will send a <code>304 Not Modified</code> status code and an empty
response body instead of the cached response.<p class="paragraph"/><h2>The Cache Headers Plugin</h2><p class="paragraph"/>The <em class="italic">Springcache</em> plugin integrates well with the <a href="http://grails.org/plugin/cache-headers" target="blank">Cache Headers</a> plugin. Some examples:<p class="paragraph"/><h3>Preventing caching</h3><p class="paragraph"/>If you want to prevent <em class="italic">Springcache</em> from caching a response in certain circumstances:<p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"myCache"</span>)
def myAction = &#123;
	// &#8230;
	<span class="java&#45;keyword">if</span> (someConditionHoldsThatMeansThisShouldNotGetCached) &#123;
		cache <span class="java&#45;keyword">false</span>
	&#125;
	// &#8230;
&#125;</pre></div><p class="paragraph"/>Alternatively you might want to declare <code>&#64;Cacheable</code> at the class level and then exclude a particular action from the
cache:<p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"myCache"</span>)
class MyController &#123;<p class="paragraph"/>	// ...<p class="paragraph"/>	def myAction = &#123;
		cache <span class="java&#45;keyword">false</span>
		// &#8230;
	&#125;</pre></div><p class="paragraph"/><h3>Controlling cache expiry</h3><p class="paragraph"/>As explained above cache time-to-live will respect the max-age in a cache control header.<p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"myCache"</span>)
def myAction = &#123;
	cache validFor: 3600
	// &#8230;
&#125;</pre></div><p class="paragraph"/>In this example the response will be cached with a time-to-live of one hour <em class="italic">regardless</em> of the default time-to-live
configured on the cache itself.<p class="paragraph"/><h3>Sending Not-Modified responses</h3><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"myCache"</span>)
def show = &#123;
	withCacheHeaders &#123;
		def book = Book.get(params.id)
		etag &#123;
			<span class="java&#45;quote">"$&#123;book.ident()&#125;:$&#123;book.version&#125;"</span>
		&#125;
		lastModified &#123;
			book.dateCreated ?: book.dateUpdated
		&#125;
		generate &#123;
			render view: <span class="java&#45;quote">"show"</span>, model: &#91;item: book&#93;
		&#125;
	&#125;
&#125;</pre></div><p class="paragraph"/>In this example the response will be cached and any subsequent requests that send matching <code>If-Modified-Since</code> and/or
<code>If-None-Match</code> headers will be sent a <code>304 Not Modified</code> response if they hit the cache.
<h2><a name="4.5. Content Cache Keys">4.5. Content Cache Keys</a></h2>The Springcache plugin uses an instance of the interface <code>grails.plugin.springcache.key.KeyGenerator</code> to generate the cache key. The default implementation is a bean named <em class="italic">springcacheDefaultKeyGenerator</em> which is of type <code>grails.plugin.springcache.web.key.DefaultKeyGenerator</code>. If you want to use a different key generator for a particular action you just need to add the <code>keyGenerator</code> element to the <code>&#64;Cacheable</code> annotation specifying the name of a Spring bean that implements the <code>KeyGenerator</code> interface.<p class="paragraph"/><div class="code"><pre>@Cacheable(cache = <span class="java&#45;quote">"albumControllerCache"</span>, keyGenerator = <span class="java&#45;quote">"myKeyGenerator"</span>)
def list = &#123;
    // &#8230;
&#125;</pre></div><p class="paragraph"/>Alternatively you can override the default key generator by redefining the <em class="italic">springcacheDefaultKeyGenerator</em> bean in _resources.groovy_.<p class="paragraph"/><blockquote class="note">
The <code>keyGenerator</code> element is only for content caching and just works on controllers, it is ignored by the <code>&#64;Cacheable</code> annotation on service methods and taglibs.
</blockquote><p class="paragraph"/><h3><code>grails.plugin.springcache.web.key.DefaultKeyGenerator</code></h3><p class="paragraph"/>The <code>DefaultKeyGenerator</code> generates a key based on the controller name, action name and any request parameters (which can be from a query string, <em class="italic">POST</em> body or those added by Grails URL mappings, e.g. the <em class="italic">id</em> parameter on a standard <em class="italic">show</em> or <em class="italic">edit</em> action).<p class="paragraph"/><h3><code>grails.plugin.springcache.web.key.WebContentKeyGenerator</code></h3><p class="paragraph"/><code>WebContentKeyGenerator</code> is a multi-purpose <code>KeyGenerator</code> implementation that exposes a number of boolean properties that control key generation. All the properties default to <em class="italic">false_.<p class="paragraph"/><h5>ajax</h5><p class="paragraph"/>If _true</em> then keys will differ depending on the presence or absence of the <code>X-Requested-With</code> request header so <em class="italic">AJAX</em> requests will be cached separately from regular requests. This is useful when you have an action that renders different content when it is requested via <em class="italic">AJAX_.<p class="paragraph"/><h5>contentType</h5><p class="paragraph"/>If _true</em> keys will differ depending on the requested content format as determined by the <code>format</code> meta-property on <code>HttpServletRequest</code>. This is useful when you use content negotiation in a request so that responses with different formats are cached separately.<p class="paragraph"/>See <a href="../guide/single.html#4.6. Content Negotiation" class="guide">Content Negotiation</a> for more detail.<p class="paragraph"/><h5>requestMethod</h5><p class="paragraph"/>If <em class="italic">true</em> keys will differ depending on the request HTTP method. This is useful for some <em class="italic">RESTful</em> controllers (although if different request methods are mapped to different actions you do not need to use this mechanism). <em class="italic">GET</em> and <em class="italic">HEAD</em> requests are considered the same for the purposes of key generation.<p class="paragraph"/><h4>Example configuration</h4><p class="paragraph"/><div class="code"><pre>ajaxAwareKeyGenerator(WebContentKeyGenerator) &#123;
	ajax = <span class="java&#45;keyword">true</span>
&#125;<p class="paragraph"/>contentTypeAwareKeyGenerator(WebContentKeyGenerator) &#123;
	contentType = <span class="java&#45;keyword">true</span>
&#125;</pre></div><p class="paragraph"/><h2><a name="4.6. Content Negotiation">4.6. Content Negotiation</a></h2>By default the key generator used by the page fragment caching filter does not take content negotiation into account. However, if you are caching controller actions that use Grails' <a href="http://grails.org/doc/latest/ref/Controllers/withFormat.html" target="blank"><code>withFormat</code></a> dynamic method to render different content types you will want to cache results separately according to the output format. You can use the <code>WebContentKeyGenerator</code> class to do this. You just need to register a key generator bean with Spring and then annotate any content negotiated actions like this:<p class="paragraph"/><h4>grails-app/conf/spring/resources.groovy</h4><p class="paragraph"/><div class="code"><pre>mimeTypeAwareKeyGenerator(WebContentKeyGenerator) &#123;
	contentType = <span class="java&#45;keyword">true</span>
&#125;</pre></div><p class="paragraph"/><h4>grails-app/controllers/MyController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(cache = <span class="java&#45;quote">"albumControllerCache"</span>, keyGenerator = <span class="java&#45;quote">"mimeTypeAwareKeyGenerator"</span>)
def list = &#123;
    def albumList = Album.list()
	withFormat &#123;
		html &#123; &#91;albumList: albumList&#93; &#125;
		xml &#123; render albumList as XML &#125;
		json &#123; render albumList as JSON &#125;
	&#125;
&#125;</pre></div>
<h2><a name="4.7. Full Page Caching">4.7. Full Page Caching</a></h2>The plugin only provides page fragment caching rather than full page caching. Full page caching is very simple to apply using the <em class="italic">EhCache-Web</em> library that the Springcache plugin uses. See my blog post <a href="http://adhockery.blogspot.com/2010/02/full-page-caching-in-grails-with.html" target="blank">here</a> for details.
<h2><a name="4.8. TagLib Caching">4.8. TagLib Caching</a></h2>An alternative to using includes for caching smaller page fragments is to use caching on taglib tags. When a cacheable tag is called, the parameters it is called with from the cache key. If there is no entry in the cache, the tag is executed and the output that it generated is cached (as well as being written to the page). If there is an entry in the cache, the tag is not executed and the cached output is written to the page.<p class="paragraph"/><div class="code"><pre>class BlogArticlesTagLib &#123;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> namespace = <span class="java&#45;quote">"blogarticles"</span><p class="paragraph"/>    def blogArticlesService<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"blogArticlesTagCache"</span>)
    def allArticles = &#123; attrs &#45;&#62;
        out &#60;&#60; <span class="java&#45;quote">"&#60;ul&#62;"</span>
        blogArticlesService.getArticles(attrs.id).each &#123;
            out &#60;&#60; <span class="java&#45;quote">"&#60;li&#62;$&#123;it.title&#125;&#60;/li&#62;"</span>
        &#125;
        out &#60;&#60; <span class="java&#45;quote">"&#60;/ul&#62;"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>When we call the tag like so…<p class="paragraph"/><div class="code"><pre>&#60;blogarticles:allArticles id=<span class="java&#45;quote">"$&#123;blogId&#125;"</span> /&#62;</pre></div><p class="paragraph"/>The cache key is formed by the 'id' tag. This tag can be reused across different views without changing the caching semantics. That is, the controller/action that the cacheable tag is called from <strong class="bold">does not</strong> affect the cache key.<p class="paragraph"/><h3>Tags with a body</h3><p class="paragraph"/>When caching a tag with a body, if there is a cache hit the body will not be executed. Therefore it doesn't make sense to cache a tag that is invoked with a different body unless you are ensuring the right cacheability through the tag parameters (i.e. cache keys).<h1><a name="5. Cache Selection">5. Cache Selection</a></h1>In some specialised circumstances you may need to programatically select the cache used when a <code>&#64;Cacheable</code> or <code>&#64;CacheFlush</code> annotation is hit. An example might be a multi-tenant application where optimising cache utilisation by caching content for different tenants in their own caches would make sense.<p class="paragraph"/>To apply cache selection you need a bean in the Spring context that implements the <code>grails.plugin.springcache.CacheResolver</code> interface. The interface is extremely simple having only one method <code>resolveCacheName(String)</code> which is passed the "base" cache name declared on your annotation and should return the <em class="italic">actual</em> cache name to use. You can then add a <code>cacheResolver</code> parameter to <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations referencing the bean name of your <code>CacheResolver</code> implementation.<p class="paragraph"/>You can override the default <code>CacheResolver</code> used by the plugin by simply redefining the bean <em class="italic">springcacheDefaultCacheResolver</em> in _resources.groovy_.<p class="paragraph"/><h3>Example usage</h3><p class="paragraph"/>A simple example based on the <a href="http://grails.org/plugin/multi-tenant-core" target="blank">Multi-Tenant</a> plugin. Cached actions should use a different cache depending on the current tenant.<p class="paragraph"/>First we define a <code>CacheResolver</code> implementation that will simply append the current tenant id to the base cache name:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.springcache.CacheResolver
<span class="java&#45;keyword">import</span> org.springframework.web.context.request.RequestContextHolder<p class="paragraph"/>class MultiTenantCacheResolver <span class="java&#45;keyword">implements</span> CacheResolver &#123;<p class="paragraph"/>	def tenantResolver // a component of the Multi&#45;Tenant plugin, see that plugin's documentation<p class="paragraph"/>	<span class="java&#45;object">String</span> resolveCacheName(<span class="java&#45;object">String</span> baseName) &#123;
		def request = RequestContextHolder.requestAttributes.currentRequest
		def tenantId = tenantResolver.getTenantFromRequest(request)
		<span class="java&#45;quote">"$&#123;baseName&#125;&#45;tenant&#45;$&#123;tenantId&#125;"</span>
	&#125;
&#125;</pre></div><p class="paragraph"/>Then we need to wire up our cache resolver in the Spring application context in the <code>grails-app/conf/spring/resources.groovy</code> file and wiring in the dependency on the <em class="italic">tenantResolver</em> bean provided by the Multi-Tenant plugin.<p class="paragraph"/><div class="code"><pre>multiTenantCacheResolver(MultiTenantCacheResolver) &#123;
	tenantResolver = ref(<span class="java&#45;quote">"tenantResolver"</span>)
&#125;</pre></div><p class="paragraph"/>Finally we just need to reference the <em class="italic">multiTenantCacheResolver</em> bean on any annotations in parts of the code that need to be multi-tenant aware:<p class="paragraph"/><div class="code"><pre>@Cacheable(cache = <span class="java&#45;quote">"userCache"</span>, cacheResolver = <span class="java&#45;quote">"multiTenantCacheResolver"</span>)
def list = &#123;
	&#91;users: User.list()&#93; // under the multi&#45;tenant plugin <span class="java&#45;keyword">this</span> will only <span class="java&#45;keyword">return</span> user instances <span class="java&#45;keyword">for</span> the current tenant
&#125;<p class="paragraph"/>@CacheFlush(caches = <span class="java&#45;quote">"userCache"</span>, cacheResolver = <span class="java&#45;quote">"multiTenantCacheResolver"</span>)
def save = &#123;
	def user = <span class="java&#45;keyword">new</span> User(params)
	// &#8230; save the <span class="java&#45;keyword">new</span> user, redirect, handle errors, etc.
&#125;</pre></div><p class="paragraph"/><blockquote class="warning">
If you use cache selection when it's not really appropriate it's very easy to get into problems with cache invalidation and stale data.
</blockquote>
<h1><a name="6. Programmatic Caching and Flushing">6. Programmatic Caching and Flushing</a></h1>Both the servlet filter used for content caching and the AOP aspects used for service method caching use a Grails service to handle caching and flushing. Your application can access this service directly if you need to do any programmatic caching or flushing. The service is called <em class="italic">springcacheService</em> and can be auto-injected into your Grails artefacts just like any other Spring bean. The service provides the following methods:
<ul class="star">
<li><strong class="bold">doWithCache(String, Serializable, Closure)</strong> : Parameters are cache name, cache key and closure invoked when there is no cached value. The method returns either the cached value or the return value of the closure. If the closure is invoked the return value is cached.</li>
<li><strong class="bold">doWithBlockingCache(String, Serializable, Closure)</strong> : A variant of doWithCache that ensures a BlockingCache is used and handles exceptions so that the cache's lock is relinquished correctly.</li>
<li><strong class="bold">flush(patterns)</strong> : Flushes all caches matching the specified names/patterns. The parameter can be a String, a regex pattern or a Collection or array of them.</li>
<li><strong class="bold">flushAll()</strong> : Flushes all caches.</li>
<li><strong class="bold">clearStatistics()</strong> : Clears statistics for all caches.</li>
<li><strong class="bold">getOrCreateCache(name)</strong> : Gets the named cache or creates it from defaults if it does not exist.</li>
<li><strong class="bold">getOrCreateBlockingCache(name)</strong> : As <em class="italic">getOrCreateCache</em> but will decorate the cache with a <a href="http://ehcache.org/apidocs/net/sf/ehcache/constructs/blocking/BlockingCache.html" target="blank">BlockingCache</a> if it is non-blocking.</li>
</ul><p class="paragraph"/>The plugin encourages you to use declarative caching and flushing to maintain a good separation of concerns. Over-using the <em class="italic">springcacheService</em> is likely to render your code harder to test and maintain. That said programmatic caching may be necessary in some places but there are some caveats:
<ul class="star">
<li>If you try to perform caching or flushing in interceptors on controller actions bear in mind those actions, and therefore any interceptors, will not be invoked at all if they are annotated with <code>&#64;Cacheable</code> and the cache is hit.</li>
<li>Controller actions don't <em class="italic">return</em> HTML output so you can't do fine grained content caching by using <code>springcacheService.doWithCache</code> in a controller action.</li>
</ul><p class="paragraph"/><h1><a name="7. Cache Configuration">7. Cache Configuration</a></h1>Caches referenced by the annotations can be configured, either in an <code>ehcache.xml</code> (usually kept in the <code>grails-app/conf</code> directory) file, using <code>EhCacheFactoryBean</code> definitions in <code>grails-app/conf/spring/resources.groovy</code> or via <code>Config.groovy</code>. If you do not configure caches individually they will be created on demand using defaults.<p class="paragraph"/><h3>Configuring caches with resources.groovy</h3><p class="paragraph"/>You can configure caches in <code>grails-app/conf/spring/resources.groovy</code> using instances of Spring's <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/cache/ehcache/EhCacheFactoryBean.html" target="blank">EhCacheFactoryBean</a> class. For example:<p class="paragraph"/><h4>grails-app/conf/spring/resources.groovy</h4><p class="paragraph"/><div class="code"><pre>pirateCache(EhCacheFactoryBean) &#123; bean &#45;&#62;
    cacheManager = ref(<span class="java&#45;quote">"springcacheCacheManager"</span>)
    cacheName = <span class="java&#45;quote">"pirateCache"</span>
    // these are just examples of properties you could set
    eternal = <span class="java&#45;keyword">false</span>
    diskPersistent = <span class="java&#45;keyword">false</span>
    memoryStoreEvictionPolicy = <span class="java&#45;quote">"LRU"</span>
&#125;</pre></div><p class="paragraph"/>You can inherit default cache properties from those defined in <code>Config.groovy</code> by setting the factory bean's parent to '<code>springcacheDefaultCache</code>'. For example:<p class="paragraph"/><div class="code"><pre>pirateCache(EhCacheFactoryBean) &#123; bean &#45;&#62;
    bean.parent = ref(<span class="java&#45;quote">"springcacheDefaultCache"</span>)
    cacheName = <span class="java&#45;quote">"pirateCache"</span>
    // set any properties unique to <span class="java&#45;keyword">this</span> cache
    memoryStoreEvictionPolicy = <span class="java&#45;quote">"LRU"</span>
&#125;</pre></div><p class="paragraph"/><h3>Configuring caches with Config.groovy</h3><p class="paragraph"/>The Springcache plugin enables you to define caches in <code>Config.groovy</code> for convenience. For example:<p class="paragraph"/><h4>grails-app/conf/Config.groovy</h4><p class="paragraph"/><div class="code"><pre>springcache &#123;
    defaults &#123;
        // set <span class="java&#45;keyword">default</span> cache properties that will apply to all caches that <span class="java&#45;keyword">do</span> not override them
        eternal = <span class="java&#45;keyword">false</span>
        diskPersistent = <span class="java&#45;keyword">false</span>
    &#125;
    caches &#123;
        pirateCache &#123;
            // set any properties unique to <span class="java&#45;keyword">this</span> cache
            memoryStoreEvictionPolicy = <span class="java&#45;quote">"LRU"</span>
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>Under the hood this is simply setting up <code>EhCacheFactoryBean</code> instances in the Spring context, so it is up to you whether you prefer to use <code>resources.groovy</code> or <code>Config.groovy</code> there is not much difference.<p class="paragraph"/>The properties shown are just examples, see the <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/cache/ehcache/EhCacheFactoryBean.html" target="blank">EhCacheFactoryBean</a> documentation for full details of all the properties you can set.
<h2><a name="8.1. Tips">8.1. Tips</a></h2><h3>Flushing content caches with service methods and vice-versa</h3><p class="paragraph"/>There is nothing special about the different types of cache so it's perfectly fine to flush a content cache with a <code>&#64;CacheFlush</code> annotation on a service method or a service method cache with a <code>&#64;CacheFlush</code> annotation on a controller action. There's also no reason that you shouldn't use the same cache for both service method and content caching the keys will be quite distinct so this will not be a problem.<p class="paragraph"/><h3>Tearing down caches in tests</h3><p class="paragraph"/>In integration test and some types of functional test (e.g. <a href="http://grails.org/plugin/selenium-rc" target="blank">Selenium RC</a> tests when not running in remote mode) your tests can have Spring beans automatically injected. You can use this facility to tear down caches between tests. For example:<p class="paragraph"/><div class="code"><pre>def springcacheService // auto&#45;injected service bean from plugin<p class="paragraph"/>void tearDown() &#123;
    <span class="java&#45;keyword">super</span>.tearDown()
    springcacheService.flushAll()
    // only need to <span class="java&#45;keyword">do</span> <span class="java&#45;keyword">this</span> <span class="java&#45;keyword">if</span> your tests are making assertions about hit/miss counts, etc.
    springcacheService.clearStatistics()
&#125;</pre></div><p class="paragraph"/><h3>Disabling</h3><p class="paragraph"/>Rather than tearing down caches between tests you may prefer to disable the plugin altogether. This is done by setting the config key <code>springcache.enabled = false</code> which can be done on a per-environment basis. For example:<p class="paragraph"/><div class="code"><pre>springcache &#123;
    // cache definitions, etc
&#125;<p class="paragraph"/>environments &#123;
    development &#123;
        springcache.enabled = <span class="java&#45;keyword">false</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>Whilst this makes things simpler I would encourage you to run end-to-end tests and continuous integration in as 'production-like' an environment as possible. If your continuous integration build is running with the plugin enabled you are much less likely to get any surprising behaviour when you release your app to a production environment.<p class="paragraph"/><h3>Logging</h3><p class="paragraph"/>To see logging from the plugin set the logging level on <code>grails.plugin.springcache</code> in your <code>Config.groovy</code> file.<p class="paragraph"/><h3>Response headers</h3><p class="paragraph"/>The plugin sets a header <em class="italic">X-Springcache-Cached</em> with a value of <em class="italic">true</em> or <em class="italic">false</em> to indicate whether or not a controller response was served from the cache. This only applies to the "main" request and not to any content included using the <code>g:include</code> tag.
<h2><a name="8.2. FAQ">8.2. FAQ</a></h2><h3>Can I evict only some of the contents of a cache instead of flushing the whole thing?</h3><p class="paragraph"/>No. It's not possible to 'reverse engineer' cache keys into the values that were used to generate them so how would you know which keys to evict? If you find yourself asking this question you should consider using more focused caches rather than putting everything into the same bucket. The pursuit of 100% efficiency where no service method or controller action is <em class="italic">ever</em> invoked when its contents could conceivably have been served from a cache is subject to the law of diminishing returns. Any time you flush a cache you may well discard <em class="italic">some</em> entries that <em class="italic">could</em> potentially still have been used but so long as your caches are set up sensibly that's really not something that you should worry about.<p class="paragraph"/><h3>My cache config doesn't seem to be working.</h3><p class="paragraph"/>Ensure all your config for the <em class="italic">Springcache</em> plugin is nested inside a single <code>springcache</code> block in <code>Config.groovy</code> otherwise only the last block will take effect.<p class="paragraph"/><h3>Can I programatically disable caching in specific circumstances such as when a user is logged in?</h3><p class="paragraph"/>In the case of controller caching you can do so by setting a <em class="italic">Cache-Control</em> response header with a value of <em class="italic">"no-cache"</em> which can be done manually, or by using the command <code>cache false</code> provided by the <a href="http://grails.org/plugin/cache-headers" target="blank">Cache Headers</a> plugin. See <a href="../guide/single.html#4.4. Cache Headers" class="guide">Cache Headers</a><p class="paragraph"/><h3>Why isn't there a taglib so I can just wrap parts of my page that need caching?</h3><p class="paragraph"/>It's something I may add but from a purist point of view I'm not very keen on the idea. Caching is a separate concern from view rendering and the two really shouldn't be mixed up. So far the plugin has deliberately taken a declarative approach to caching which encourages you to maintain a good separation of concerns.<p class="paragraph"/>If this is something you really want to see, vote for the issue on JIRA here: "GRAILSPLUGINS-2564":http://jira.codehaus.org/browse/GRAILSPLUGINS-2564<h2><a name="8.3. Upgrading From Earlier Versions">8.3. Upgrading From Earlier Versions</a></h2>Successive versions of the plugin have introduced some non-backwards compatible changes. If you are upgrading from an earlier version you will need to consider the following:<p class="paragraph"/><h4>Upgrading from 1.2.* to 1.3:</h4>
<ul class="star">
<li>You can no longer inject <em class="italic">keyGenerator</em> into the <em class="italic">springcacheFilter</em> bean. Instead you can override the <em class="italic">springcacheDefaultKeyGenerator</em> bean or specify the <em class="italic">keyGenerator</em> element on individual <code>&#64;Cacheable</code> annotations. See <a href="../guide/single.html#4.5. Content Cache Keys" class="guide">Content Cache Keys</a></li>
</ul><p class="paragraph"/><h4>Upgrading from 1.1.* to 1.2:</h4>
<ul class="star">
<li>The plugin no longer uses caching and flushing models. Instead cache names are referenced directly by the annotations. This means you will need to 'inline' your model definitions from <code>Config.groovy</code> to your annotations.</li>
<li>The plugin no longer supports alternate cache libraries, it's <em class="italic">EhCache</em> or nothing.</li>
</ul><p class="paragraph"/><h4>From pre 1.1:</h4>
<ul class="star">
<li>You will need to change the import statements for your <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations to point to the <code>grails.plugin.springcache.annotations</code> package.</li>
</ul><p class="paragraph"/>
        </div>
        <div id="footer">
             Developed by the <a href='http://gpc.github.com'>Grails Plugin Collective</a>
        </div>
    </body>
</html>
