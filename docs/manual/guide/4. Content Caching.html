<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>4. Content Caching</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="4. Content Caching">4. Content Caching</a></h1>The <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations can be applied to controller actions and the plugin will then cache the page fragment generated by the controller whether this is done by rendering a GSP, using a <em class="italic">MarkupBuilder</em> closure, rendering text directly or whatever. Only successful page renders are cached, so redirects, 404s, errors and so on will not be.<p class="paragraph"/>Composing pages so that they can be optimally cached requires some thought. The plugin uses a servlet filter that runs 'inside' the SiteMesh filter provided by Grails. This means that cached output is decorated by SiteMesh and the resulting page can therefore contain uncached content from the SiteMesh template. In addition you can use caching at a modular level to cache the output of controller actions invoked using the <code>g:include</code> tag. Combining these techniques leads to powerful modular page caching. For example, you can cache the output of the 'main' controller then use <code>g:include</code> tags in the SiteMesh layout to include content on the page that is cached separately - and can be flushed separately - from the main body of the page.
<h2><a name="4.1. Caching and Flushing with Controller Actions">4.1. Caching and Flushing with Controller Actions</a></h2><h3>Example: caching Grails CRUD pages</h3><p class="paragraph"/>Grails' standard scaffolded <em class="italic">CRUD</em> pages provide a good example of how caching and flushing can be applied. For example, let's take an <em class="italic">Album</em> domain class. The scaffolded controller could be annotated like this:<p class="paragraph"/><h4>AlbumController.groovy</h4><p class="paragraph"/><div class="code"><pre>class AlbumController &#123;
    // the index action is uncached as it just performs a redirect to list
    def index = &#123;
        redirect(action: <span class="java&#45;quote">"list"</span>, params: params)
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def list = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def create = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @CacheFlush(&#91;<span class="java&#45;quote">"albumControllerCache"</span>, <span class="java&#45;quote">"artistControllerCache"</span>, <span class="java&#45;quote">"latestControllerCache"</span>, <span class="java&#45;quote">"popularControllerCache"</span>&#93;)
    def save = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def show = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def edit = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @CacheFlush(&#91;<span class="java&#45;quote">"albumControllerCache"</span>, <span class="java&#45;quote">"latestControllerCache"</span>, <span class="java&#45;quote">"popularControllerCache"</span>&#93;)
    def update = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @CacheFlush(&#91;<span class="java&#45;quote">"albumControllerCache"</span>, <span class="java&#45;quote">"artistControllerCache"</span>, <span class="java&#45;quote">"latestControllerCache"</span>, <span class="java&#45;quote">"popularControllerCache"</span>&#93;)
    def delete = &#123;
        // standard Grails scaffolding code omitted
    &#125;
&#125;</pre></div><p class="paragraph"/>The <em class="italic">list, show, create</em> and <em class="italic">edit</em> pages are all cached. The <em class="italic">show</em> and <em class="italic">edit</em> rely on an domain object id parameter and this will be included in the cache key so that <code>/album/show/1</code> and <code>/album/show/2</code> are cached separately. The <em class="italic">save, update</em> and <em class="italic">delete</em> actions will flush caches. Note that in addition to flushing the cache used by the <em class="italic">list, show, create</em> and <em class="italic">edit</em> actions they are flushing other caches which are content caches for controllers whose output should be refreshed if <code>Album</code> data changes.
<h2><a name="4.2. Content Caching and SiteMesh">4.2. Content Caching and SiteMesh</a></h2><h3>Example: decorating a cached page with dynamic content using SiteMesh</h3><p class="paragraph"/>It is often necessary to have portions of a page be dynamic. A typical example is when something is displayed to logged in users that will be different for each user. Those sorts of page sections are not really candidates for caching. At the same time other parts of the page may well be able to take advantage of caching. For example, if you want to display a <em class="italic">"Welcome back $username"</em> type message in page headers while caching the main body of the page you can use SiteMesh templates like this:<p class="paragraph"/><h4>grails-app/views/layouts/main.gsp</h4><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
    &#60;head&#62;
        &#60;title&#62;&#60;g:layoutTitle <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Welcome to My Grails Application"</span>/&#62;&#60;/title&#62;
        &#60;%&#45;&#45; render the page head from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutHead/&#62;
    &#60;/head&#62;
    &#60;body&#62;
        &#60;%&#45;&#45; render a <span class="java&#45;quote">"welcome back"</span> header (tags used here are from the Spring Security plugin) &#45;&#45;%&#62;
        &#60;g:isLoggedIn&#62;
            &#60;div id=<span class="java&#45;quote">"loggedInUser"</span>&#62;&#60;g:message code=<span class="java&#45;quote">"auth.loggedInAs"</span> args=<span class="java&#45;quote">"&#91;loggedInUsername()&#93;"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Logged in as &#123;0&#125;"</span>/&#62;&#60;/div&#62;
        &#60;/g:isLoggedIn&#62;
        &#60;g:isNotLoggedIn&#62;
            &#60;div id=<span class="java&#45;quote">"loginLink"</span>&#62;&#60;g:link controller=<span class="java&#45;quote">"login"</span>&#62;&#60;g:message code=<span class="java&#45;quote">"<span class="java&#45;keyword">default</span>.login.label"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Login here"</span>/&#62;&#60;/g:link&#62;&#60;/div&#62;
        &#60;/g:isNotLoggedIn&#62;<p class="paragraph"/>        &#60;%&#45;&#45; render the page body from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutBody/&#62;
    &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>If the controller action invoked uses <code>&#64;Cacheable</code> everything will work fine because the content of the SiteMesh layout is <em class="italic">not</em> cached - only the content generated by the cached action. The SiteMesh template is applied to cached and uncached content alike so the correct username will be displayed to your users even though the main body of the page may have been loaded from a cache.<p class="paragraph"/><h3>Example: a modular page using multiple cached sections</h3><p class="paragraph"/>One of the most powerful features of page fragment caching is that the generated page can be composed from multiple cached sections. This is accomplished using Grails' <code>g:include</code> tag. For example, in this page the main body of the page is rendered by some controller action and the output of other controllers are included in the SiteMesh layout using the <code>g:include</code> tag:<p class="paragraph"/><h4>grails-app/views/layouts/main.gsp</h4><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
    &#60;head&#62;
        &#60;title&#62;&#60;g:layoutTitle <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Welcome to My Grails Application"</span>/&#62;&#60;/title&#62;
        &#60;%&#45;&#45; render the page head from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutHead/&#62;
    &#60;/head&#62;
    &#60;body&#62;
        &#60;%&#45;&#45; render the page body from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutBody/&#62;<p class="paragraph"/>        &#60;div class=<span class="java&#45;quote">"sidebar"</span>&#62;
            &#60;%&#45;&#45; each of these controller actions can be cached separately as well &#45;&#45;%&#62;
            &#60;g:include controller=<span class="java&#45;quote">"latest"</span> action=<span class="java&#45;quote">"albums"</span>/&#62;
            &#60;g:include controller=<span class="java&#45;quote">"popular"</span> action=<span class="java&#45;quote">"albums"</span>/&#62;
        &#60;/div&#62;
    &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><h4>LatestController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"latestAlbums"</span>)
def albums = &#123;
    def albums = Album.list(sort: <span class="java&#45;quote">"dateCreated"</span>, order: <span class="java&#45;quote">"desc"</span>, max: 10)
    &#91;albumInstanceList: albums&#93;
&#125;</pre></div><p class="paragraph"/><h4>LatestController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"popularAlbums"</span>)
def albums = &#123;
    def albums = Album.listOrderByAverageRating(max: 10)
    <span class="java&#45;keyword">return</span> &#91;albumInstanceList: albums&#93;
&#125;</pre></div><p class="paragraph"/>If all the caches are hit the final rendered page will be composed of 3 separate cached sections. What is more, each individual section can be flushed without affecting the others so with some thought about how to compose your page and apply your caches you can optimise cache usage without delivering stale data to the user.
<h2><a name="4.3. Using Annotations at Class Level">4.3. Using Annotations at Class Level</a></h2>The <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations can be applied to controllers at class level. This is more likely useful with <code>&#64;Cacheable</code> but it is certainly possible to apply <code>&#64;CacheFlush</code> at class level so that any action on that controller will flush a set of caches. Any annotation on an individual action will be applied in preference to an annotation at class level, so a class level annotation behaves like a default. An annotation at class level will work with dynamic scaffolded actions so you don't have to generate a concrete action in order to benefit from caching behaviour.<p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
class AlbumController &#123;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> scaffold = <span class="java&#45;keyword">true</span> // all dynamically scaffolded actions will be cached<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumListCache"</span>)
    def list = &#123;
        // &#8230;
    &#125;<p class="paragraph"/>    @CacheFlush(/album&#119;+Cache/)
    def save = &#123;
        // &#8230;
    &#125;<p class="paragraph"/>    def show = &#123;
        // &#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>In this example:
<ul class="star">
<li>The <em class="italic">show</em> action will use the default class level <code>&#64;Cacheable</code> annotation and its page fragment will be cached in the <em class="italic">albumControllerCache</em> cache.</li>
<li>The <em class="italic">list</em> action will not use the default as it specifies its own <code>&#64;Cacheable</code> annotation and its content will be cached separately.</li>
<li>The <em class="italic">save</em> action uses a <code>&#64;CacheFlush</code> and will therefore not be cached at all.</li>
<li>Dynamically scaffolded actions (e.g. <em class="italic">edit_, _update_, etc.) will use the class level annotation and their results will be cached in the _albumControllerCache</em> cache.</li>
</ul><p class="paragraph"/><h2><a name="4.4. Content Cache Keys">4.4. Content Cache Keys</a></h2>By default page fragment cache entries are keyed on controller name, action name and any request parameters (which can be from a query string, <em class="italic">POST</em> body or those added by Grails URL mappings, e.g. the <em class="italic">id</em> parameter on a standard <em class="italic">show</em> or <em class="italic">edit</em> action). If you need to use some kind of special key generation you can implement the interface <code>grails.plugin.springcache.web.key.KeyGenerator</code> (or extend <code>grails.plugin.springcache.web.key.AbstractKeyGenerator</code> or one of the existing implementations that the plugin provides) then simply override the Spring bean property on the filter in <code>Config.groovy</code> like this:<p class="paragraph"/><div class="code"><pre>beans &#123;
    springcacheFilter &#123;
		keyGenerator = <span class="java&#45;keyword">new</span> MyKeyGenerator()
	&#125;
&#125;</pre></div>
<h2><a name="4.5. Content Negotiation">4.5. Content Negotiation</a></h2>By default the key generator used by the page fragment caching filter does not take content negotiation into account. However, if you are caching controller actions that use Grails' <a href="http://grails.org/doc/latest/ref/Controllers/withFormat.html" target="blank"><code>withFormat</code></a> dynamic method to render different content types you will want to cache results separately according to the output format. The plugin provides a key generator implementation that supports this, you just need to override the filter's key generator in <code>Config.groovy</code> like this:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.springcache.web.key.MimeTypeAwareKeyGenerator<p class="paragraph"/>beans &#123;
    springcacheFilter &#123;
		keyGenerator = <span class="java&#45;keyword">new</span> MimeTypeAwareKeyGenerator()
	&#125;
&#125;</pre></div>
<h2><a name="4.6. Full Page Caching">4.6. Full Page Caching</a></h2>The plugin only provides page fragment caching rather than full page caching. Full page caching is very simple to apply using the <em class="italic">EhCache-Web</em> library that the Springcache plugin uses. See my blog post <a href="http://adhockery.blogspot.com/2010/02/full-page-caching-in-grails-with.html" target="blank">here</a> for details.

    </body>
</html>
