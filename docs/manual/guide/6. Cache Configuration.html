<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>6. Cache Configuration</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="6. Cache Configuration">6. Cache Configuration</a></h1>Caches referenced by the annotations can be configured, either in an <code>ehcache.xml</code> (usually kept in the <code>grails-app/conf</code> directory) file, using <code>EhCacheFactoryBean</code> definitions in <code>grails-app/conf/spring/resources.groovy</code> or via <code>Config.groovy</code>. If you do not configure caches individually they will be created on demand using defaults.<p class="paragraph"/><h3>Configuring caches with resources.groovy</h3><p class="paragraph"/>You can configure caches in <code>grails-app/conf/spring/resources.groovy</code> using instances of Spring's <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/cache/ehcache/EhCacheFactoryBean.html" target="blank">EhCacheFactoryBean</a> class. For example:<p class="paragraph"/><h4>grails-app/conf/spring/resources.groovy</h4><p class="paragraph"/><div class="code"><pre>pirateCache(EhCacheFactoryBean) &#123; bean &#45;&#62;
    cacheManager = ref(<span class="java&#45;quote">"springcacheCacheManager"</span>)
    cacheName = <span class="java&#45;quote">"pirateCache"</span>
    // these are just examples of properties you could set
    eternal = <span class="java&#45;keyword">false</span>
    diskPersistent = <span class="java&#45;keyword">false</span>
    memoryStoreEvictionPolicy = <span class="java&#45;quote">"LRU"</span>
&#125;</pre></div><p class="paragraph"/>You can inherit default cache properties from those defined in <code>Config.groovy</code> by setting the factory bean's parent to '<code>springcacheDefaultCache</code>'. For example:<p class="paragraph"/><div class="code"><pre>pirateCache(EhCacheFactoryBean) &#123; bean &#45;&#62;
    bean.parent = ref(<span class="java&#45;quote">"springcacheDefaultCache"</span>)
    cacheName = <span class="java&#45;quote">"pirateCache"</span>
    // set any properties unique to <span class="java&#45;keyword">this</span> cache
    memoryStoreEvictionPolicy = <span class="java&#45;quote">"LRU"</span>
&#125;</pre></div><p class="paragraph"/><h3>Configuring caches with Config.groovy</h3><p class="paragraph"/>The Springcache plugin enables you to define caches in <code>Config.groovy</code> for convenience. For example:<p class="paragraph"/><h4>grails-app/conf/Config.groovy</h4><p class="paragraph"/><div class="code"><pre>springcache &#123;
    defaults &#123;
        // set <span class="java&#45;keyword">default</span> cache properties that will apply to all caches that <span class="java&#45;keyword">do</span> not override them
        eternal = <span class="java&#45;keyword">false</span>
        diskPersistent = <span class="java&#45;keyword">false</span>
    &#125;
    caches &#123;
        pirateCache &#123;
            // set any properties unique to <span class="java&#45;keyword">this</span> cache
            memoryStoreEvictionPolicy = <span class="java&#45;quote">"LRU"</span>
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>Under the hood this is simply setting up <code>EhCacheFactoryBean</code> instances in the Spring context, so it is up to you whether you prefer to use <code>resources.groovy</code> or <code>Config.groovy</code> there is not much difference.<p class="paragraph"/>The properties shown are just examples, see the <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/cache/ehcache/EhCacheFactoryBean.html" target="blank">EhCacheFactoryBean</a> documentation for full details of all the properties you can set.
<h2><a name="7.1. Tips">7.1. Tips</a></h2><h3>Flushing content caches with service methods and vice-versa</h3><p class="paragraph"/>There is nothing special about the different types of cache so it's perfectly fine to flush a content cache with a <code>&#64;CacheFlush</code> annotation on a service method or a service method cache with a <code>&#64;CacheFlush</code> annotation on a controller action.<p class="paragraph"/><h3>Tearing down caches in tests</h3><p class="paragraph"/>In integration test and some types of functional test (e.g. <a href="http://grails.org/plugin/selenium-rc" target="blank">Selenium RC</a> tests when not running in remote mode) your tests can have Spring beans automatically injected. You can use this facility to tear down caches between tests. For example:<p class="paragraph"/><div class="code"><pre>def springcacheService // auto&#45;injected service bean from plugin<p class="paragraph"/>void tearDown() &#123;
    <span class="java&#45;keyword">super</span>.tearDown()
    springcacheService.flushAll()
    // only need to <span class="java&#45;keyword">do</span> <span class="java&#45;keyword">this</span> <span class="java&#45;keyword">if</span> your tests are making assertions about hit/miss counts, etc.
    springcacheService.clearStatistics()
&#125;</pre></div><p class="paragraph"/><h3>Disabling</h3><p class="paragraph"/>Rather than tearing down caches between tests you may prefer to disable the plugin altogether. This is done by setting the config key <code>springcache.disabled = true</code> which can be done on a per-environment basis. For example:<p class="paragraph"/><div class="code"><pre>springcache &#123;
    // cache definitions, etc
&#125;<p class="paragraph"/>environments &#123;
    development &#123;
        springcache.disabled = <span class="java&#45;keyword">true</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>Whilst this makes things simpler I would encourage you to run end-to-end tests and continuous integration in as 'production-like' an environment as possible. If your continuous integration build is running with the plugin enabled you are much less likely to get any surprising behaviour when you release your app to a production environment.<p class="paragraph"/><h3>Logging Output</h3><p class="paragraph"/>To see logging from the plugin set the logging level on <code>grails.plugin.springcache</code> in your <code>Config.groovy</code> file.<p class="paragraph"/><h2><a name="7.2. FAQ">7.2. FAQ</a></h2><h3>My cache config doesn't seem to be working.</h3><p class="paragraph"/>Ensure all your config for the <em class="italic">Springcache</em> plugin is nested inside a single <code>springcache</code> block in <code>Config.groovy</code> otherwise only the last block will take effect.<p class="paragraph"/><h3>Can I programatically disable caching in specific circumstances such as when a user is logged in?</h3><p class="paragraph"/>Not right now, although I hope to add this to a future release of the plugin. I'd encourage you to think about structuring your pages using <em class="italic">SiteMesh</em> layouts and the <code>g:include</code> tag such that it is possible to separate the dynamic and cacheable sections.<p class="paragraph"/><h3>Why isn't there a taglib so I can just wrap parts of my page that need caching?</h3><p class="paragraph"/>It's something I may add but from a purist point of view I'm not very keen on the idea. Caching is a separate concern from view rendering and the two really shouldn't be mixed up. So far the plugin has deliberately taken a declarative approach to caching which encourages you to maintain a good separation of concerns.<p class="paragraph"/><h3>Can I use <code>&#64;Cacheable</code> on taglib Closures?</h3><p class="paragraph"/>Not yet. This is definitely on the roadmap for a future version of the plugin.
<h2><a name="7.3. Upgrading From Earlier Versions">7.3. Upgrading From Earlier Versions</a></h2>Successive versions of the plugin have introduced some non-backwards compatible changes. If you are upgrading from an earlier version you will need to consider the following:<p class="paragraph"/><h4>Upgrading from 1.1.* to 1.2:</h4>
<ul class="star">
<li>The plugin no longer uses caching and flushing models. Instead cache names are referenced directly by the annotations. This means you will need to 'inline' your model definitions from <code>Config.groovy</code> to your annotations.</li>
<li>The plugin no longer supports alternate cache libraries, it's <em class="italic">EhCache</em> or nothing.</li>
</ul><p class="paragraph"/><h4>From pre 1.1:</h4>
<ul class="star">
<li>You will need to change the import statements for your <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations to point to the <code>grails.plugin.springcache.annotations</code> package.</li>
</ul><p class="paragraph"/>
    </body>
</html>
