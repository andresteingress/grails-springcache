<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>4.2. Content Caching and SiteMesh</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h3>Example: decorating a cached page with dynamic content using SiteMesh</h3><p class="paragraph"/>It is often necessary to have portions of a page be dynamic. A typical example is when something is displayed to logged in users that will be different for each user. Those sorts of page sections are not really candidates for caching. At the same time other parts of the page may well be able to take advantage of caching. For example, if you want to display a <em class="italic">"Welcome back $username"</em> type message in page headers while caching the main body of the page you can use SiteMesh templates like this:<p class="paragraph"/><h4>grails-app/views/layouts/main.gsp</h4><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
    &#60;head&#62;
        &#60;title&#62;&#60;g:layoutTitle <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Welcome to My Grails Application"</span>/&#62;&#60;/title&#62;
        &#60;%&#45;&#45; render the page head from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutHead/&#62;
    &#60;/head&#62;
    &#60;body&#62;
        &#60;%&#45;&#45; render a <span class="java&#45;quote">"welcome back"</span> header (tags used here are from the Spring Security plugin) &#45;&#45;%&#62;
        &#60;g:isLoggedIn&#62;
            &#60;div id=<span class="java&#45;quote">"loggedInUser"</span>&#62;&#60;g:message code=<span class="java&#45;quote">"auth.loggedInAs"</span> args=<span class="java&#45;quote">"&#91;loggedInUsername()&#93;"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Logged in as &#123;0&#125;"</span>/&#62;&#60;/div&#62;
        &#60;/g:isLoggedIn&#62;
        &#60;g:isNotLoggedIn&#62;
            &#60;div id=<span class="java&#45;quote">"loginLink"</span>&#62;&#60;g:link controller=<span class="java&#45;quote">"login"</span>&#62;&#60;g:message code=<span class="java&#45;quote">"<span class="java&#45;keyword">default</span>.login.label"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Login here"</span>/&#62;&#60;/g:link&#62;&#60;/div&#62;
        &#60;/g:isNotLoggedIn&#62;<p class="paragraph"/>        &#60;%&#45;&#45; render the page body from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutBody/&#62;
    &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>If the controller action invoked uses <code>&#64;Cacheable</code> everything will work fine because the content of the SiteMesh layout is <em class="italic">not</em> cached - only the content generated by the cached action. The SiteMesh template is applied to cached and uncached content alike so the correct username will be displayed to your users even though the main body of the page may have been loaded from a cache.<p class="paragraph"/><h3>Example: a modular page using multiple cached sections</h3><p class="paragraph"/>One of the most powerful features of page fragment caching is that the generated page can be composed from multiple cached sections. This is accomplished using Grails' <code>g:include</code> tag. For example, in this page the main body of the page is rendered by some controller action and the output of other controllers are included in the SiteMesh layout using the <code>g:include</code> tag:<p class="paragraph"/><h4>grails-app/views/layouts/main.gsp</h4><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
    &#60;head&#62;
        &#60;title&#62;&#60;g:layoutTitle <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Welcome to My Grails Application"</span>/&#62;&#60;/title&#62;
        &#60;%&#45;&#45; render the page head from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutHead/&#62;
    &#60;/head&#62;
    &#60;body&#62;
        &#60;%&#45;&#45; render the page body from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutBody/&#62;<p class="paragraph"/>        &#60;div class=<span class="java&#45;quote">"sidebar"</span>&#62;
            &#60;%&#45;&#45; each of these controller actions can be cached separately as well &#45;&#45;%&#62;
            &#60;g:include controller=<span class="java&#45;quote">"latest"</span> action=<span class="java&#45;quote">"albums"</span>/&#62;
            &#60;g:include controller=<span class="java&#45;quote">"popular"</span> action=<span class="java&#45;quote">"albums"</span>/&#62;
        &#60;/div&#62;
    &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><h4>LatestController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"latestAlbums"</span>)
def albums = &#123;
    def albums = Album.list(sort: <span class="java&#45;quote">"dateCreated"</span>, order: <span class="java&#45;quote">"desc"</span>, max: 10)
    &#91;albumInstanceList: albums&#93;
&#125;</pre></div><p class="paragraph"/><h4>LatestController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"popularAlbums"</span>)
def albums = &#123;
    def albums = Album.listOrderByAverageRating(max: 10)
    <span class="java&#45;keyword">return</span> &#91;albumInstanceList: albums&#93;
&#125;</pre></div><p class="paragraph"/>If all the caches are hit the final rendered page will be composed of 3 separate cached sections. What is more, each individual section can be flushed without affecting the others so with some thought about how to compose your page and apply your caches you can optimise cache usage without delivering stale data to the user.

	</body>
</html>