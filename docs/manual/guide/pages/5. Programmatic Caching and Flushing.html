<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>5. Programmatic Caching and Flushing</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    Both the servlet filter used for content caching and the AOP aspects used for service method caching use a Grails service to handle caching and flushing. Your application can access this service directly if you need to do any programmatic caching or flushing. The service is called <em class="italic">springcacheService</em> and can be auto-injected into your Grails artefacts just like any other Spring bean. The service provides the following methods:
<ul class="star">
<li><strong class="bold">doWithCache(String, Serializable, Closure)</strong> : Parameters are cache name, cache key and closure invoked when there is no cached value. The method returns either the cached value or the return value of the closure. If the closure is invoked the return value is cached.</li>
<li><strong class="bold">doWithBlockingCache(String, Serializable, Closure)</strong> : A variant of doWithCache that ensures a BlockingCache is used and handles exceptions so that the cache's lock is relinquished correctly.</li>
<li><strong class="bold">flush(patterns)</strong> : Flushes all caches matching the specified names/patterns. The parameter can be a String, a regex pattern or a Collection or array of them.</li>
<li><strong class="bold">flushAll()</strong> : Flushes all caches.</li>
<li><strong class="bold">clearStatistics()</strong> : Clears statistics for all caches.</li>
<li><strong class="bold">getOrCreateCache(name)</strong> : Gets the named cache or creates it from defaults if it does not exist.</li>
<li><strong class="bold">getOrCreateBlockingCache(name)</strong> : As <em class="italic">getOrCreateCache</em> but will decorate the cache with a <a href="http://ehcache.org/apidocs/net/sf/ehcache/constructs/blocking/BlockingCache.html" target="blank">BlockingCache</a> if it is non-blocking.</li>
</ul><p class="paragraph"/>The plugin encourages you to use declarative caching and flushing to maintain a good separation of concerns. Over-using the <em class="italic">springcacheService</em> is likely to render your code harder to test and maintain. That said programmatic caching may be necessary in some places but there are some caveats:
<ul class="star">
<li>If you try to perform caching or flushing in interceptors on controller actions bear in mind those actions, and therefore any interceptors, will not be invoked at all if they are annotated with <code>&#64;Cacheable</code> and the cache is hit.</li>
<li>Controller actions don't <em class="italic">return</em> HTML output so you can't do fine grained content caching by using <code>springcacheService.doWithCache</code> in a controller action.</li>
</ul><p class="paragraph"/>
    </body>
</html>
